Graphs are bascially of 2 types:
    -> A Graph is a collection of Nodes (Vertexes) and Edges (Connections).

1. Directed Graphs
2. Undirected Graphs.

1. DIRECTED GRAPHS:
   (A) --> (B)
    ^       |
    |       v
   (D) <-- (C)
  -> A,B,C,D are nodes or also called vertexes.
  -> the lines that are pointing in between with arrows are called edges or also called directed edges.

2. UN-DIRECTED GRAPHS:
   (1) --- (2)
    |       |
    |       |
   (3) --- (4)
   -> Unlike Directed graphs these have no direction edges so they can go forward or backward.

3. WEIGHTED GRAPHS:
  (1) --5-- (2)
    |        /
   3|      /2
    |    /
   (3)
   -> Here edges have weight that can be eg: costs, distance etc.
   -> If the edges are not assigned then we consider the weight of the edge to be 1.

CYCLES IN A GRAPH:
    1. Undirected Cyclic Graph: here there are cycles between the edges that pass through.
    2. directed Acyclic Graph: here there will be no cycles between the edges that are present.
        -> Also called as DAG.
    3. directed cyclic Graph: a directed edges having a cycle.

PATHS: Can contain a lot of nodes or vertexes and each of them is reachable.
 NOTES:
    1. In a path to be valid node that come onces should not repeat again.
    2. all the nodes of that path should be connected and in a path no node should be skipped that are inbetween.

DEGREES:
    -> The number of edges attached to a node is called degrees.
    -> Total degree of a graph is => 2 * Edges.
    DIRECTED GRAPH:
        -> Contains two types of Nodes.
        1. InDegree Nodes. -> the edges that are directed to that node is called InDegree nodes. (Incoming Edges)
        2. OutDegree Nodes. -> the edges that are directed in other direction to that node is called OutDegree Nodes. (OutDirected Edges).



ğŸŒ Graph Algorithms Mind Map.
Graph Algorithms
â”‚
â”œâ”€â”€ Traversal
â”‚   â”œâ”€â”€ BFS (Breadth-First Search)
â”‚   â””â”€â”€ DFS (Depth-First Search)
â”‚
â”œâ”€â”€ Shortest Path
â”‚   â”œâ”€â”€ Dijkstra (no negative weights)
â”‚   â”œâ”€â”€ Bellman-Ford (handles negatives)
â”‚   â”œâ”€â”€ Floyd-Warshall (all pairs)
â”‚   â”œâ”€â”€ Johnsonâ€™s Algorithm (all pairs + negatives)
â”‚   â””â”€â”€ A* (heuristic-based pathfinding)
â”‚
â”œâ”€â”€ Minimum Spanning Tree (MST)
â”‚   â”œâ”€â”€ Kruskalâ€™s Algorithm
â”‚   â””â”€â”€ Primâ€™s Algorithm
â”‚
â”œâ”€â”€ Topological Ordering (DAGs)
â”‚   â”œâ”€â”€ DFS-based Topological Sort
â”‚   â””â”€â”€ Kahnâ€™s Algorithm (BFS-based)
â”‚
â”œâ”€â”€ Connectivity & Components
â”‚   â”œâ”€â”€ Union-Find (Disjoint Set Union - DSU)
â”‚   â”œâ”€â”€ Tarjanâ€™s Algorithm (SCC)
â”‚   â””â”€â”€ Kosarajuâ€™s Algorithm (SCC)
â”‚
â”œâ”€â”€ Flow & Matching
â”‚   â”œâ”€â”€ Ford-Fulkerson (Max Flow)
â”‚   â”œâ”€â”€ Edmonds-Karp (BFS version of Ford-Fulkerson)
â”‚   â””â”€â”€ Hopcroft-Karp (Bipartite Matching)
â”‚
â””â”€â”€ Other Specialized
    â”œâ”€â”€ Eulerian Path / Circuit (Chinese Postman)
    â”œâ”€â”€ Hamiltonian Path (NP-complete)
    â”œâ”€â”€ Traveling Salesman Problem (TSP)
    â””â”€â”€ PageRank (Google's ranking algorithm)


